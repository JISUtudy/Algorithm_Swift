# 1927 â†’ ìµœì†Œí™
### ë¬¸ì œ ì •ë¦¬ğŸ“
1. í™ì— ë„£ì„ `ìˆ˜ì˜ ê°œìˆ˜`ë¥¼ ì…ë ¥ë°›ëŠ”ë‹¤.
2. í™ì— ë„£ì„ ê°ê°ì˜ ìˆ˜ë¥¼ ê°œí–‰ ì…ë ¥ë°›ëŠ”ë‹¤.
3. ì•„ë˜ì˜ ê·œì¹™ì— ë”°ë¼ ì¶œë ¥í•œë‹¤.
```
â€¢ 0 ì…ë ¥
    â€¢ í™ì´ ë¹„ì–´ìˆì„ ê²½ìš° â†’ 0 ì¶œë ¥
    â€¢ í™ì´ ë¹„ì–´ìˆì§€ ì•Šì„ ê²½ìš° â†’ í™ì˜ ìµœì†Ÿê°’ ì¶œë ¥ 
```


</br>

## ì ‘ê·¼ğŸš¶ğŸ»
### ë‚˜ì˜ ìƒê° â–¾
- `for`ë¬¸ìœ¼ë¡œ ê°œí–‰ ì…ë ¥ ë°›ì•„ì£¼ê³ , ì…ë ¥ìœ¼ë¡œ ë“¤ì–´ì˜¤ëŠ” ê°’ì´ `0`ì¸ì§€ ì•„ë‹Œì§€ë¡œ ê¸°ëŠ¥ì„ ë‚˜ëˆ„ì–´ì£¼ì—ˆë‹¤.

</br>


### ë‚´ ì½”ë“œğŸ‘¨ğŸ»â€ğŸ’» (ì‹œê°„ì´ˆê³¼)
```swift
let N = Int(String(readLine()!))!
var h = [Int]()

for _ in 0..<N {
    let input = Int(String(readLine()!))!

    if input == 0 {
        if !h.isEmpty { print(h.removeFirst()) }
        else { print(0)}
    } else {
        h.append(input)
        h.sort()
    }
}
```

 - ì œí•œ ì‹œê°„ì„ 1ì´ˆë¡œ ì£¼ì–´ì¡ŒëŠ”ë° Swift ê´€ë ¨í•œ ì–´ë– í•œ ì…ì¶œë ¥ ê¸°ëŠ¥ì„ ë„£ì–´ì£¼ì–´ë„ ë³€í•¨ì—†ì´ `ì‹œê°„ì´ˆê³¼`ë¼ëŠ” ê²°ê³¼ë¥¼ ë°›ì•˜ë‹¤.
 - ê²°êµ­ ë‹¤ë¥¸ë¶„ì˜ ì½”ë“œë¥¼ ì°¸ê³ í•˜ì—¬ ì œì¶œí–ˆë‹¤..

</br>

### ì°¸ê³  ì½”ë“œğŸ‘¨ğŸ»â€ğŸ’»
```swift
struct Heap<T: Comparable> {

    enum Kind {
        case max
        case min
    }

    var heapArray = [T?]()
    let kind: Kind

    mutating func insert(_ value: T) {
        if heapArray.isEmpty {
            heapArray.append(nil)
            heapArray.append(value)
        } else {
            heapArray.append(value)

            var insertedIndex = heapArray.count - 1

            while moveUp(insertedIndex) {
                let parentIndex = insertedIndex / 2
                heapArray.swapAt(insertedIndex, parentIndex)
                insertedIndex = parentIndex
            }
        }
    }

    private func moveUp(_ insertedIndex: Int) -> Bool {
        if insertedIndex <= 1 {
            return false
        } else {
            let parentIndex = insertedIndex / 2

            switch kind {
            case .max:
                if heapArray[parentIndex]! < heapArray[insertedIndex]! {
                    return true
                }
                return false
            case .min:
                if heapArray[parentIndex]! > heapArray[insertedIndex]! {
                    return true
                }
                return false
            }
        }
    }

    mutating func pop() -> T? {
        if heapArray.count <= 1 {
            return nil
        }

        let popedData = heapArray[1]!
        heapArray[1] = heapArray.last!
        heapArray.removeLast()
        var popedIndex = 1

        while moveDown(popedIndex) {
            let leftChildIndex = popedIndex * 2
            let rightChildIndex = popedIndex * 2 + 1

            // case 2: right ë…¸ë“œê°€ ì—†ëŠ” ê²½ìš° -> left ë…¸ë“œë‘ë§Œ ë¹„êµí•œë‹¤
            if rightChildIndex >= heapArray.count {
                switch kind {
                case .max:
                    if heapArray[popedIndex]! < heapArray[leftChildIndex]! {
                        heapArray.swapAt(popedIndex, leftChildIndex)
                        popedIndex = leftChildIndex
                    }
                case .min:
                    if heapArray[popedIndex]! > heapArray[leftChildIndex]! {
                        heapArray.swapAt(popedIndex, leftChildIndex)
                        popedIndex = leftChildIndex
                    }
                }
            }
            // case 3: left right ë‘˜ë‹¤ ìˆëŠ” ê²½ìš° -> left rightë¥¼ ë¹„êµí•˜ê³  root ë…¸ë“œì™€ ë¹„êµí•œë‹¤
            else {
                switch kind {
                case .max:
                    if heapArray[leftChildIndex]! > heapArray[rightChildIndex]! {
                        if heapArray[popedIndex]! < heapArray[leftChildIndex]! {
                            heapArray.swapAt(popedIndex, leftChildIndex)
                            popedIndex = leftChildIndex
                        }
                    } else {
                        if heapArray[popedIndex]! < heapArray[rightChildIndex]! {
                            heapArray.swapAt(popedIndex, rightChildIndex)
                            popedIndex = rightChildIndex
                        }
                    }
                case .min:
                    if heapArray[leftChildIndex]! > heapArray[rightChildIndex]! {
                        if heapArray[popedIndex]! > heapArray[rightChildIndex]! {
                            heapArray.swapAt(popedIndex, rightChildIndex)
                            popedIndex = rightChildIndex
                        }
                    } else {
                        if heapArray[popedIndex]! > heapArray[leftChildIndex]! {
                            heapArray.swapAt(popedIndex, leftChildIndex)
                            popedIndex = leftChildIndex
                        }
                    }
                }
            }
        }
        return popedData
    }

    private func moveDown(_ popedIndex: Int) -> Bool {

        let leftChildIndex = popedIndex * 2
        let rightChildIndex = popedIndex * 2 + 1

        // case 1: left ë…¸ë“œê°€ ì—†ëŠ” ê²½ìš° -> ë°”ê¾¸ì§€ ì•ŠëŠ”ë‹¤
        if leftChildIndex >= heapArray.count {
            return false
        }
        // case 2: right ë…¸ë“œê°€ ì—†ëŠ” ê²½ìš° -> left ë…¸ë“œë‘ë§Œ ë¹„êµí•œë‹¤
        else if rightChildIndex >= heapArray.count {
            switch kind {
            case .max:
                if heapArray[popedIndex]! < heapArray[leftChildIndex]! {
                    return true
                } else {
                    return false
                }
            case .min:
                if heapArray[popedIndex]! > heapArray[leftChildIndex]! {
                    return true
                } else {
                    return false
                }
            }
        }
        // case 3: left right ë‘˜ë‹¤ ìˆëŠ” ê²½ìš° -> left rightë¥¼ ë¹„êµí•˜ê³  root ë…¸ë“œì™€ ë¹„êµí•œë‹¤
        else {
            switch kind {
            case .max:
                if heapArray[leftChildIndex]! > heapArray[rightChildIndex]! {
                    if heapArray[popedIndex]! < heapArray[leftChildIndex]! {
                        return true
                    } else {
                        return false
                    }
                } else {
                    if heapArray[popedIndex]! < heapArray[rightChildIndex]! {
                        return true
                    } else {
                        return false
                    }
                }
            case .min:
                if heapArray[leftChildIndex]! > heapArray[rightChildIndex]! {
                    if heapArray[popedIndex]! > heapArray[rightChildIndex]! {
                        return true
                    } else {
                        return false
                    }
                } else {
                    if heapArray[popedIndex]! > heapArray[leftChildIndex]! {
                        return true
                    } else {
                        return false
                    }
                }
            }
        }
    }
}

let n = Int(readLine()!)!
var heap = Heap(heapArray: [Int](), kind: .min)
for _ in 1...n {
    let x = Int(readLine()!)!
    if x == 0 {
        print(heap.pop() ?? 0)
    } else {
        heap.insert(x)
    }
}

```

 - `heap`ì„ ì§ì ‘ êµ¬í˜„í•˜ì—¬ ë¬¸ì œë¥¼ í’€ì—ˆë‹¤.

</br>


### Additional ğŸ“‚
- ì§„ì§œ ì•Œê³ ë¦¬ì¦˜ Swiftì–¸ì–´ì— ê´€ëŒ€í•´ì¡Œìœ¼ë©´ ì¢‹ê² ë‹¤..
- Swiftë¡œ ë¬¸ì œ í‘¸ëŠ” ëª¨ë“  ì‚¬ëŒë“¤ í˜ë‚´ì„¸ìš”..ğŸ¥²
