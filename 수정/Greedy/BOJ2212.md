# 2212 → 센서
### 문제 정리📝
- 센서의 개수를 입력받는다.
- 집중국의 개수를 입력받는다.
- 센서 개수의 좌표를 입력받는다.
- 각각의 센서는 적어도 하나의 집중국과는 통신이 가능해야 한다.
- 집중국과 센서를 연결하는데 최소의 유지비를 위해 수신 가능 영역의 길이의 합을 최소화해야 한다.
- 단, 집중국의 수신 가능영역의 길이는 0 이상어야한다.

</br>

## 접근🚶🏻
### 나의 생각 ▾
- 입력받은 n개의 센서 좌표 `a`를 정렬해주었다.
- 정렬한 값 a간의 거리 `tmp`를 구해주었다.  
ex) 정렬한 값이 1 3 6 6 7 9 라면 첫번째 인덱스부터 1-3=`2`, 3-6=`3` 이런식으로 값들의 거리를 구해주었다.
- 각 집중국의 수신 가능영역 거리 합의 `최솟값`을 구하는 것이므로 a간의 거리 tmp 또한 `오름차순으로 정렬`해준다.
- 기지국의 갯수가 n개이고 집중국의 갯수가 k개라면 수신받아야하는 수신값은 `n-k개`이므로 for문을 이용해 `cnt`에 `처음 인덱스부터 n-k인덱스까지만` 더해주어 최솟값을 구할 수 있다.

</br>


### 내 코드👨🏻‍💻
```swift
let n = Int(String(readLine()!))!
let k = Int(String(readLine()!))!
var a = readLine()!.split(separator: " ").map{Int(String($0))!}.sorted(by: <)
var tmp = [Int]()
var cnt = 0

if k >= n {
    print(0)
} else {
  for i in 0..<n-1 { // 01234
    tmp.append(a[i+1]-a[i])
  }
  tmp.sort()
  
  for i in 0..<n-k { //0123
    cnt += tmp[i]
  }
  print(cnt)
}
```

</br>


### Additional 📂
- 첫 코드에는 런타임 에러가 떴는데 그 이유는 예외 상황을 처리해주지 않아 생긴 에러였다. if문을 사용하여 예외를 처리해주었다.   
    ex) 단, 집중국의 수신 가능영역의 길이는 0 이상이며 모든 센서의 좌표가 다를 필요는 없다.
    ```swift
    if k >= n {
        print(0)
    ```
- 정렬 문제는 이제 감을 좀 찾은 것 같다.


