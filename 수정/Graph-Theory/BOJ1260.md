# 1260 â†’ DFSì™€ BFS
### ë¬¸ì œ ì •ë¦¬ğŸ“
1. `ì •ì ì˜ ê°œìˆ˜(N)`, `ê°„ì„ ì˜ ê°œìˆ˜(M)`, `íƒìƒ‰ ì‹œì‘ ë…¸ë“œ(V)`ë¥¼ ì…ë ¥ë°›ëŠ”ë‹¤.
2. Kë¥¼ ì‹œì‘ìœ¼ë¡œ ì—°ê²°ëœ ê°ê°ì˜ ì •ì ë“¤ì„ `ë°©ë¬¸í•˜ëŠ” ìˆœì„œëŒ€ë¡œ ì¶œë ¥`í•œë‹¤.
> DFS ê²°ê³¼ ì¶œë ¥ í›„ BFS ê²°ê³¼ë¥¼ ê°œí–‰ ì¶œë ¥í•œë‹¤.

</br>

## ì ‘ê·¼ğŸš¶ğŸ»
### ë‚˜ì˜ ìƒê° â–¾
- DFSì™€ BFSë¥¼ ì‚¬ìš©í•˜ì—¬ í‘¸ëŠ” ê°„ë‹¨í•œ ë¬¸ì œì´ë‹¤.
- ë°©ë¬¸ì²´í¬ë¥¼ í•´ì£¼ë©° íƒìƒ‰í–ˆë‹¤.

</br>

### ë‚´ ì½”ë“œğŸ‘¨ğŸ»â€ğŸ’»
```swift
func BFS(n: Int, start: Int, node: [[Int]]) -> String {
    var isVisited = Array(repeating: false, count: n+1)
    var queue:[Int] = []
    var result = "\(start) "
    isVisited[start] = true
    queue.append(start)
    
    while !queue.isEmpty {
        let next = queue.removeFirst()
        for i in node[next].sorted() {
            if !isVisited[i] {
                queue.append(i)
                isVisited[i] = true
                result += "\(i) "
            }
        }
    }
    return result
}
func DFS(n: Int, start: Int, node: [[Int]]) -> String {
    var isVisited = Array(repeating: false, count: n+1)
    var stack:[Int] = []
    var result = ""
    stack.append(start)
    
    func dfs() {
        let next = stack.removeLast()
        isVisited[next] = true
        result += "\(next) "
        for i in node[next].sorted() {
            if !isVisited[i] {
                stack.append(i)
                dfs()
            }
        }
    }
    dfs()
    return result
}
let input = readLine()!.split(separator: " ").map{Int(String($0))!}
let n = input[0]
let m = input[1]
let startNode = input[2]
var node:[[Int]] = [[0]]
for i in 1...n {
    node.append([i])
}
for _ in 1...m {
    let line = readLine()!.split(separator: " ").map{Int(String($0))!}
    node[line[0]].append(line[1])
    node[line[1]].append(line[0])
}
print(DFS(n: n, start: startNode, node: node))
print(BFS(n: n, start: startNode, node: node))
```

</br>



</br>

### Additional ğŸ“‚
- ê¸°ì´ˆ DFS, BFS ë¬¸ì œë¼ ì¬ë¯¸ìˆì—ˆë‹¤.
